# Linear mixed models

## Motivation

Random effects are a very common addition to regression models that are used to account for grouping (categorical) variables such as subject, year, location. To explain the motivation for these models, as well as the basic syntax, we will use an example data set containing exam scores of 4,059 students from 65 schools in Inner London. This data set is located in the R package `mlmRev`.{R}.

-   Response: "normexam" (Normalized exam score).
-   Predictor 1: "standLRT" (Standardised LR test score; Reading test taken when they were 11 years old).
-   Predictor 2: "sex" of the student (F / M).
-   Grouping factor: school

If we analyze this with a simple lm, we see that reading ability and sex have the expected effects on the exam score.

```{r chunk_chapter4_chunk24, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
library(mlmRev)
library(effects)

mod0 = lm(normexam ~ standLRT + sex , data = Exam)
plot(allEffects(mod0))
```

However, it is reasonable to assume that not all schools are equally good, which has two possible consequences:

-   If school identity correlates with sex or standLRT, school could be confounder
-   Residuals will be correlated in school, thus they are not iid (pseudo-replication)

We could solve this problem by fitting a different mean per school

```{r}
mod0b = lm(normexam ~ standLRT + sex + school , data = Exam)
```

however, with 65 schools this would cost 64 degrees of freedom, which is a high cost just for correcting the possibility of confounding and a minor residual problem.

The solution: **Mixed / random effect models**. In a mixed model, we assume (differently to a fixed effect model) that the variance between schools originates from a normal distribution. There are different interpretations of a random effect (more on this later), but one interpretation is to view the random effect as an additional error, so that such a mixed model has two levels of error:

-   First, the random effect, which is a normal "error" acting on an entire group of data points (in this case school).

-   And second, the residual error, which is a normal error per observation and acts on top of the random effect

Because of this hierarchical structure, these models are also called "multi-level models" or "hierarchical models".

::: callout-note
Because grouping naturally occurs in any type of experimental data (batches, blocks, observer, subject etc.), random and mixed effect models are the de-facto default for most experimental data! Naming conventions:

-   No random effect = fixed effect model
-   Only random effects = random effect model
-   Random effects + fixed effects = mixed model

Most models that are used in practice are mixed models
:::

## The random intercept model

The simplest random effect structure is the random intercept model.

::: callout-note
Each random effect model has a fixed counterpart. For the random intercept model, this counterpart is the model we already saw, with school as a fixed effect

```{r}
mod0b = lm(normexam ~ standLRT + sex + school , data = Exam)
```
:::

The random intercept model is practically identical to the model above, except that it assumes that the school effects come from a common normal distribution. The model can be estimated with lme4::lmer

```{r chunk_chapter4_chunk25, echo=TRUE, eval=TRUE}
library(lme4)
mod1 = lmer(normexam ~ standLRT + sex +  (1 | school), data = Exam)
summary(mod1)
```

If we look at the outputs, you will probably note that the summary() function doesn't return p-values. More on this in the section on problems and solutions for mixed models. Also, we see that the effects of the individual school are not explicitly mentioned. The summary only returns the mean effects over all schools, and the variance between schools. However, you can obtain the individual school effects via

```{r, eval=F}
ranef(mod1)
```

Moreover, unlike the outputs we have seen before, the model also returns a correlation between fixed effect estimates. This, however, is simply a choice of the programmers, it has nothing to do with the random effect models - you could calculate the same output for the lm() via the function vcov().

Here is a visualization of the fitted effects for standLRT

```{r chunk_chapter4_chunk26, echo=F, eval=TRUE}
with(Exam, {
  randcoef = ranef(mod1)$school[,1]
  fixedcoef = fixef(mod1)
  plot(standLRT, normexam)
    for(i in 1:65){
      abline(a = fixedcoef[1] + randcoef[i], b = fixedcoef[2], col = i)
    }
})
```

We can see that there is the same slope, but a different intercept per school.

::: callout-note
The RE effectively "centers" the categorical predictor - unlike for the fixed effect model, where the intercept would be interpreted as the value for the first school, the intercept in the random effect model is the mean across all schools, and the REs measure the deviation of the individual school from the mean. It should be stressed, however, that this is a welcome consequence, but not the main motivation, for the RE structure.
:::

## The random slope model

A second effect that we could imagine is that the effect of `standLRT`{.R} is different for each school. As a fixed effect model, we would express this, for example, as `lm(normexam ~ standLRT*school + sex)`{.R}

The random effect equivalent is called the random slope model. A random slope model assumes that each school also gets their own slope for a given parameter (per default we will always estimate slope and intercept, but you could overwrite this, not recommended!). Let's do this for standLRT (you could of course random slopes on both predictors as well).

```{r chunk_chapter4_chunk27, echo=TRUE, eval=TRUE}
mod2 = lmer(normexam ~ standLRT + sex +  (standLRT | school), data = Exam)
summary(mod2)
```

Again, the difference to the fixed effect model is that in the random effect model, we assume that the variance between slopes come from a normal distribution. The results is similar to the random intercept model, except that we have an additional variance term for the slopes, and a term for the interaction between slopes and intercepts.

Here a visualization of the results

```{r chunk_chapter4_chunk28, echo=TRUE, eval=TRUE}
with(Exam, {
  randcoefI = ranef(mod2)$school[,1]
  randcoefS = ranef(mod2)$school[,2]
  fixedcoef = fixef(mod2)
  plot(standLRT, normexam)
    for(i in 1:65){
      abline(a = fixedcoef[1] + randcoefI[i] , b = fixedcoef[2] + randcoefS[i], col = i)
    }
})
```

::: {.callout-caution icon="false"}
#### Excercise: a mixed model for plantHeight

Take plantHeight model that we worked with already:

```{r, eval=FALSE}
library(EcoData)

oldModel <- lm(loght ~ temp, data = plantHeight)
summary(oldModel)
```

We have one observation per species. Consider that the relationship height \~ temp may be different for each family. Some families may have larger plants in general (random intercept), but it may also be that the temperature relationship changes per family (random slope). Run these two models for our problem.
:::

::: {.callout-tip collapse="true" appearance="minimal" icon="false"}
#### Solution

```{r, eval = F}
# Random intercept model

library(lme4)
library(lmerTest)
randomInterceptModel <- lmer(loght ~ temp + (1|Family), data = plantHeight)
summary(randomInterceptModel)

# Random slope model

randomSlopeModel <- lmer(loght ~ temp + (temp | Family), data = plantHeight)
summary(randomSlopeModel)

# scaling helps the optimizer
plantHeight$sTemp = scale(plantHeight$temp)

randomSlopeModel <- lmer(loght ~ sTemp + (sTemp | Family), data = plantHeight)
summary(randomSlopeModel)
```
:::

## Specifying and estimating mixed models:

### lme4 / glmmTMB

There are a large number of packages to fit mixed models in R. The main packages that you use, because they are most user-friendly and stable, are lme4 and glmmTMB. They share more or less the same syntax for random effects.

-   Random intercept: \`(1 \| group).
-   ONLY random slope for a given fixed effect: `(0 + fixedEffect | group)`{.R}.
-   Random slope + intercept + correlation (default): `(fixedEffect | group)`{.R}.
-   Random slope + intercept without correlation: `(fixedEffect || group)`{.R}, identical to\
    `(1 | group) + (0 + fixedEffect | group)`{.R}.
-   Nested random effects: `(1 | group / subgroup)`{.R}. If groups are labeled A, B, C, ... and subgroups 1, 2, 3, ..., this will create labels A1, A2 ,B1, B2, so that you effectively group in subgroups. Useful for the many experimental people that do not label subgroups uniquely, but otherwise no statistical difference to a normal (crossed) random effect.
-   Crossed random effects: You can add random effects independently, as in\
    `(1 | group1) + (1 | group2)`{.R}.

### nlme

nlme is a classic package for fitting (nonlinear) mixed effect models. I would argue that it is largely superseded by lme4 and glmmTMB, but it still offers a few special tricks that are not available in either lme4 or glmmTMB. A linear mixed model with random intercept in nlme looks like this

```{r, eval = F}
nlme::lme(Resp ~ Predictor, random=~1|Group)
```

### mgcv

If you want to use GAMs, there is basically only mgcv (or brms, if you're willing to go Bayesian).

```{r, eval = F}
mgcv::gam(Resp ~ Predictor + s(Group, bs = 're'))
```

### brms

brms is a very interesting package that allows to estimate mixed models via Bayesian Inference with STAN.

```{r, eval = F}
brms::brm(Resp ~ Predictor + (1|Group),
         data = Owls , family = poisson)
summary(mod1)
```

## Advantages and interpretation of random effects

What do the random effects mean, and why should we use them?

### Interpretation

The classical interpretation of the random intercept is that they model a group-structured residual error, i.e. they are like residuals, but for an entire group. However, this view breaks down a bit for a random slope model.

Another view this is that REs terms absorb group-structured variation in model parameters. This view works for random intercept and slope models. So, our main model fits the grand mean, and the RE models variation in the parameters, which is assumed to be normally distributed.

A third view of RE models is that they are regularized fixed effect models. What does that mean? Note again that, conceptual, every random effect model corresponds to a fixed effect model. For a random intercept model, this would be

```{r, eval = F}
lmer(y ~ x + (1|group)) => lm(y ~ x + group)
```

and for the random slope, it would be

```{r, eval = F}
lmer(y ~ x + (x|group)) => lm(y ~ x * group)
```

So, alternatively to a mixed model, we could always fit a fixed effect model, and that would also take care of the variation in groups. Of course, the output of the two models differs, but that's just what people programmed. The real difference, however, is that by making the assumption that the random effects come from a normal distribution, we are imposing a constraint on the estimates, which creates a shrinkage on the fitted REs (see below).

### RE shrinkage

To understand shrinkage, note that whatever the fitted sd of the normal distribution underlying the RE, as long as it is finite, it will always be more likely that the RE estimate is at zero (i.e. the grand mean) than at 1 or 2 sd. This means that RE estimates are biased towards the grand mean.

We can visualize the effect by comparing estimates of a fixed to a random effect model

```{r}
mf = lm(normexam ~ 0 + school, data = Exam)
mr = lmer(normexam ~ (1 | school), data = Exam)

ef = coef(mf)
er = ranef(mr)$school$`(Intercept)`
plot(ef, er, xlab = "fixed", ylab = "random")
abline(0,1)
```

The plot shows that random effect estimates are biased towards the grand mean, i.e. positive values are lower than in the LM, and negative values are higher than in the LM. This is called shrinkage.

::: callout-note
The shrinkage imposed by the RE is equivalent to an L2 (ridge) regression (see section on model selection), or a normally distributed Bayesian prior. You can see this by considering that the log likelihood of a normal distribution is equivalent to a quadratic penalty for deviations from the mean. The difference is that the strength of the penalty, controlled by the RE sd, is estimated. For that reason, the RE shrinkage is also referred to as an example of "adaptive shrinkage".
:::

This RE shrinkage is useful in many situations, beyond describing a group-structured error in the data. A common use is that by using a random slope model, parameter estimates for groups with few data points are drawn towards the grand mean and thus informed by the estimates of the other groups. For example, if we have data for common and rare species, and we are interested in the density dependence of the species, we could fit

```{r chunk_chapter4_chunk30, echo=TRUE, eval=FALSE, purl=FALSE}
mortality ~ density + (density | species)
```

In such a model, we have the mean density effect across all species, and rare species with few data will be constrained by this effect, while common species with a lot of data can overrule the normal distribution imposed by the random slope and get their own estimate. In this picture, the random effect imposes an adaptive shrinkage, similar to a LASSO or ridge shrinkage estimator, with the shrinkage strength controlled by the standard deviation of the random effect. An alternative view is that the RE variance acts as a prior distribution on the slope.

### When to use what?

So, to finalize this discussion: there are essentially two main differences between a random vs. fixed effect model

1.  In the RE model, we are fitting a grand mean and differences from the grand mean, while in the fixed effect model, we have to set up contrasts (various options), with treatment contrasts as defaults
2.  The LM (OLS) is mathematically proven to be the best linear unbiased estimator (BLUE) of the regression problem. In a mixed model, REs (but not fixed effects) are biased towards the grand mean, but the advantage is that the random effect looses less degrees of freedom, i.e. the power on the fixed effects will be higher.

While point 1 is more a choice about how to report results (in principle, we could also calculate the grand mean for fixed effect group estimates), the second point (higher power) is a clear advantage in many cases, in particular if you don't care about the bias on the REs. Therefore, the rule of thumb for REs is:

-   If you have a categorical variable, and you're not interested in it's estimates, model it as a RE

-   If you want to get unbiased estimates of the categorical variable (or its interactions), use a fixed effect

This is just a rule of thumb, as said, in data-poor situations, it is common to use random slope models and interpret the estimates as well. In this case, we are using the RE to optimize the bias-variance trade-off (see chapter on model selection).

## Model checks

As residual checks for an LMM, you should first of all check for everything that you would check in an LM, i.e. you would expect that the residual distribution is iid normal. On top of that, you should check the REs for:

1.  Convergence (mixed models often have convergence problems)
2.  Normality
3.  Correlation with predictors -\> RE can mask misfit
4.  Residual patterns -\> evidence for random slope

I will show all of those using the example

```{r}
mod1 = lmer(normexam ~ standLRT + sex +  (1 | school), data = Exam)
summary(mod1)
```

### Convergence

If there is a convergence problem, you should usually get a warning. Other signs of convergence problems may be RE estimates that are zero, CIs that are extremely large, or strong correlations in the correlation matrix of the predictors that is reported by summary(). Here, we have no problems, but we'll see examples of this as we go on

### Observation-level residual plots

Unfortunately, lme4 plots only provide res \~ fitted as default

```{r}
plot(mod1)
```

For a qqplot, you have to calculate the residuals by hand

```{r}
qqnorm(residuals(mod1))
```

You can also use the DHARMa plots

```{r}
library(DHARMa)
res <- simulateResiduals(mod1, plot = T)
```

Both plots look fine. Of course, we should also check residuals against predictors. In DHARMa, we can do this via

```{r}
par(mfrow = c(1,2))
plotResiduals(res, Exam$standLRT)
plotResiduals(res, Exam$sex)
```

::: callout-tip
When you predict with a random effect model, you can do conditional or marginal predictions. The difference is that conditional predictions include the REs, while marginal predictions only include the fixed effects.

```{r, eval = F}
residuals(mod1, re.form = NULL) # conditional, default
predict(mod1, re.form = ~0) # marginal
```

This also makes a difference for the residual calculations: in principle, you could calculate residuals with respect to both predictions. In practice, the default in lme4 is to calculate residual predictions

```{r, eval = F}
residuals(mod1)
Exam$normexam - predict(mod1, re.form = NULL) 
Exam$normexam - predict(mod1, re.form = ~0) 
```

while the default in DHARMa is to calculate marginal predictions. Both has advantages and disadvantages:

1.  Conditional predictions are more sensitive to violations of the iid normal assumptions of the outer (observation-level) normal errlr
2.  However, REs can sometimes absorb misfit, such that plotting conditional residuals \~ pred looks fine, but uncoditional \~ pred does not. For that reason, if you use unconditional predictions, you should also check REs \~ pred (see below)
:::

### Normality of REs

I prefer to look at this visually. You can run a shapiro.test() but if you have more REs, this will always be significant, so I find a qqplot more informative

```{r}
x = ranef(mod1)
qqnorm(x$school$`(Intercept)`)
```

### Correlation of REs with predictors

As mentioned above, REs can sometimes absorb misfit of the fixed effect structure. It can therefore be useful to check if there is a correlation with the predictors, especially if you only check conditional residuals. Example:

```{r}
y = aggregate(cbind(standLRT, sex) ~ school, FUN = mean, data = Exam)
plot(x$school$`(Intercept)` ~ y$standLRT)
```

### Residual pattern per group

lme4 has an excellent plot syntax to plot residuals per grouping factor. Check out the help of plot.merMod. The following plot shows residuals \~ fitted for each school

```{r}
plot(mod1, resid(., scaled=TRUE) ~ standLRT | school, abline = 0)
```

Looks still good to me, but if we think we see a pattern here, we should introduce a random slope.

::: {.callout-caution icon="false"}
## Case Study 1: College Student Performance Over Time

***Background and data structure***

The GPA (college grade point average) data is a **longitudinal** data set (also named **panel data**, German: "LÃ¤ngsschnittstudie". A study repeated at several different moments in time, compared to a **cross-sectional study** (German: "Querschnittstudie") which has several participants at *one time*). In this data set, 200 college students and their GPA have been followed 6 consecutive semesters. Look at the GPA data set, which can be found in the `EcoData`{.R} package:

```{r chunk_chapter4_chunk29, echo=TRUE, eval=F}
library(EcoData)
str(gpa)
```

In this data set, there are GPA measures on 6 consecutive **occasions**, with a **job** status variable (how many hours worked) for the same 6 occasions. There are two student-level explanatory variables: The **sex** (1 = male, 2 = female) and the high school **gpa**. There is also a dichotomous student-level outcome variable, which indicates whether a student has been **admitted** to the university of their choice. Since not every student applies to a university, this variable has many missing values. Each **student** and each **year** of observation have an id.

***Task***

Analyze if GPA improves over time (**occasion**)! Here a few hints to look at:

-   Consider which fixed effect structure you want to fit. For example, you might be interested if males and femals differ in their temporal trend
-   Student is the grouping variable -\> RE. Which RE structure do you want to fit? A residual plot may help
-   For your benefit, have a look at the difference in the regression table (confidence intervals, coefficients and p-values) of mixed and corresponding fixed effects model. You can also look at the estimates of the mixed effects model (hint: `?ranef`{.R}).
-   After having specified the mixed model, have a look at residuals. You can model dispersion problems in mixed models with glmmTMB, same syntax for REs as lme4
:::

::: {.callout-tip collapse="true" appearance="minimal" icon="false"}
## Solution

```{r chunk_chapter4_task_2, eval = F}
library(lme4)
library(glmmTMB)
library(EcoData)
# initial model with a random intercept and fixed effect structure based on
# causal assumptions

gpa$sOccasion = scale(gpa$occasion)
gpa$nJob = as.numeric(gpa$job)

fit <- lmer(gpa ~ sOccasion*sex + nJob + (1|student), data = gpa)
summary(fit)

# plot seems to show a lot of differences still, so add random slope
plot(fit, 
     resid(., scaled=TRUE) ~ fitted(.) | student, 
     abline = 0)

# slope + intercept model
fit <- lmer(gpa ~ sOccasion*sex + nJob + (sOccasion|student), data = gpa)

# checking residuals - 
plot(fit)


# I'm using here glmmTMB, alternatively could add weights nlme::lme, which also allows specifying mixed models with all variance modelling options that we discussed for gls, but random effect specification is different than here
fit <- glmmTMB(gpa ~ sOccasion*sex + nJob + (sOccasion|student), data = gpa, dispformula = ~ sOccasion)
summary(fit)

# unfortunately, the dispersion in this model cannot be reliably checked, because the functions for this are not (yet) implemented in glmmTMB
plot(residuals(fit, type = "pearson") ~ predict(fit)) # not implemented
library(DHARMa)
simulateResiduals(fit, plot = T) 

# still, the variable dispersion model is highly supported by the data and clearly preferable over a fixed dispersion model
```
:::

## Problems With Mixed Models

Specifying mixed models is quite simple, however, there is a large list of (partly quite complicate) issues in their practical application. Here, a (incomplete) list:

### Degrees of freedom for a random effect

Possibly the most central problem is: How many parameters does a random effect model have?

::: callout-note
Why is it so important to know how many parameters a model has? The answer is that what seems like a very minor point is needed in all the mathematics for calculating p-values, AIC, LRTs and all that, so without knowing the complexity of the model, the mathematics that is used in lm() breaks down.
:::

We can make some guesses about the complexity of an LMM by looking at its fixed effect version counterparts:

```{r eval=F}
mod1 = lm(normexam ~ standLRT + sex , data = Exam)
mod1$rank # 3 parameters.

mod2 = lmer(normexam ~ standLRT + sex +  (1 | school), data = Exam)
# No idea how many parameters.

mod3 = lm(normexam ~ standLRT + sex + school, data = Exam)
mod3$rank # 67 parameters.
```

So, we see that the fixed effect model without school has 3 parameters, and with school 67. It is reasonable to assume that the complexity of the mixed model is somewhere in-between, because it fits the same effects as mod3, but they are constrained by the normal distribution.

The width of this normal distribution is controlled by the estimated variance of the random effect. For a high variance, the normal is very wide, and the mixed model is nearly as complex as mod3; but for a low variance, the normal is very narrow, and the mixed model it is only as complex as mod1.

::: callout-note
Technically, the mixed model mod2 actually has one parameter more than the fixed effect model mod3 - it also estimates the standard deviation of the random effects. Could it thus ever be more flexible than mod3? The answer is no - the RE standard deviation is what is technically called a hyperparameter. It is not an effect that is estimated, but rather a parameter that controls the freedom of the estimated effects. The number of parameters that are used to estimate the response are identical in mod2 and mod3.
:::

Because of these issues, `lmer`{.R} by default does not return p-values. The help advises you to use bootstrapping to generate valid confidence intervals and p-values on parameters. This is possible indeed, but very cumbersome.

However, you can calculate p-values based on approximate degrees of freedom via the `lmerTest`{.R} package, which also corrects ANOVA for random effects, but not AIC.

```{r chunk_chapter4_chunk32, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
library(lmerTest)

m2 = lmer(normexam ~ standLRT + sex +  (1 | school), data = Exam, REML = F)
summary(m2)
```

::: {.callout-caution icon="false"}
## Excercise: mixed vs. fixed effect models

For the plantHeigt mixed models in the previous exercise, compare the p-values of the slope for temp to the fixed-effect equivalent (adding family as main effect / interaction). What do you find?
:::

::: {.callout-tip collapse="true" appearance="minimal" icon="false"}
## Solution

```{r, eval = F}
fixedInterceptModel <- lm(loght ~ temp + Family, data = plantHeight)
summary(fixedInterceptModel)

fixedSlopeInterceptModel <- lm(loght ~ temp * Family, data = plantHeight)
summary(fixedSlopeInterceptModel)
```

So, for the model with a different intercept per Family, the p-value decreases, and for intercept + interaction, it even becomes n.s. (although it should be noted that we get a different p-values for each species here).

The reason for the generally lower p-values (= higher power) of the mixed model is the lower flexibility of the mixed model:

For the fixed effect models, we loose 69 respectively 2x69 df if we add family as a predictor. For the mixed model, it depends on the variance estimate: wide sd of the RE, loose nearly 69df, narrow sd = loose nothing except the sd estimate -\> flexibility of an random effect model is adaptive (not fixed).

Follow-up: have a look at the variance estimates for the REs - how wide are they? Are the RE estimates effectively "free" to move?
:::

### Predictions

Related to the interpretation of an RE is the question whether the REs should be included when you make predictions or calculate other outputs of the model, e.g. residuals.

-   Marginal predictions = predictions without the RE, i.e. predict the grand mean

-   Conditional predictions = predictions with RE

In some, but unfortunately not all packages, the predict function can be adjusted. In lme4, this is via the option re.form, which is available in the predict and simulate function. Let look again at a simple random intercept model

```{r}
m = lmer(normexam ~ standLRT + sex +  (1 | school), data = Exam)
```

To generate predictions from this model, use the following syntax.

```{r, eval = F}
predict(m, re.form = NULL) # include all random effects
predict(m, re.form = ~0) # include no random effects, identical re.form = NA
predict(m, re.form = ~ (1|school)) # condition ONLY on 1|school
```

The third option is in this case identical to the first, but if we would add more REs to the model, it would differ.

::: callout-tip
Do you know how to get the correct help function for an S3 object? Concretely, how do we get the help for predicting with a fitted mixed model? `?predict` alone will not work, because this will call the general help. What you need is predict.CLASSNAME, where CLASSNAME is the class of the object on which you want to work on. In R, you get the class via

```{r}
class(m)
```

So, a model fitted with lme4 is of class lmerMod. If we want to get the help for predicting from such a class, we have to type

```{r}
?predict.merMod
```
:::

A second issue with predictions is that, unlike for lm() and glm objects, lme4 again does not calculate a standard error on the predictions due to the degree of freedom problem. Unfortunately, the lmerTest package does not help us in this case either, so now we have to resort to the parametric bootstrap, which is implemented in lme4

For this, we generate first a function that generates predictions

```{r}
pred <- function(m) predict(m,re.form = NA)
```

Note regarding this function that

-   We could add the argument newdata if we wanted to predict to newdata

-   Here, we have re.form = NA, which is identical to reform = \~0, meaning that we predict the grand mean

Second, we now bootstrap this prediction to generate an uncertainty of the prediction

```{r, eval = F}
boot <- bootMer(m, pred, nsim = 100, re.form = NA)

# visualize results
plot(boot)

# get 95% confidence interval 
confint(boot)
```

### REML vs. MLE

Frequentist linear mixed models are usually estimated with REML = restricted maximum likelihood, rather than with classical MLE. Most packages allow you to switch between REML and MLE. The motivation for REML is that for limited data (non-asymptotics), the MLE for variance components of the model are typically negatively biased, because the uncertainty of the fixed effects is not properly accounted for. If you go through the mathematics, you can make an analogy to the bias-corrected sampling variance [@bates2011computational].

REML uses a mathematical transformation to first obtain the residuals conditional on the fixed effect components of the model (thus accounting for the df lost in this part), and then estimating variance components. One can view REML as a special case of an expectation maximization (EM) algorithm.

Most packages offer an option to switch between REML and ML estimation of the model. In lme4, this is done via

```{r, echo = F}
m = lmer(normexam ~ standLRT + sex +  (1 | school), data = Exam)
m = lmer(normexam ~ standLRT + sex +  (1 | school), data = Exam, REML = F)
```

Regarding when to use what, use the following rule of thumb:

-   Per default, use REML

-   Switch to ML if you use downstream any model functions that use the likelihood, unless you are really sure that the calculation you do is also valid for REML.

::: callout-tip
In the next part of the book, we will talk about model selection via LRTs and AIC. Because those depend on the likelihood, it is generally recommended to switch from REML to ML in this case. The reason is that, because REML estimates the REs conditional on the fixed effects, REML likelihoods are not directly comparable if fixed effects are changed. I would recommend to stick to this, although I have to say that I have always wondered how big this problem is, compared to the other df problems associated to mixed models (see below).
:::

### Model selection with mixed models

For model selection, the degrees of freedom problem means that normal model selection techniques such as AIC or naive LRTs don't work on the random effect structure, because they don't count the correct degrees of freedom.

However, assuming that by changing the fixed effect structure, the flexibility of the REs doesn't change a lot (you would see this by looking at the RE sd), we can use standard model selection on the fixed effect structure. All I have said about model selection on standard models applies also here: good for predictions, rarely a good idea if your goal is causal inference.

Regarding the random effect structure - my personal recommendation for most cases is the following:

1.  add random intercept on all obvious grouping variables
2.  check residuals per group (e.g. with the plot function below), add random slope if needed

```{r, eval = F}
m1 <- lmer(y ~ x + (1|group))

plot(m1, 
     resid(., scaled=TRUE) ~ fitted(.) | group, 
     abline = 0)
```

If you absolutely want to do model selection on the RE structure

-   lmerTest::ranova performs an ANOVA with estimated df, adding entire RE groups
-   if you want to do details model selections on the RE structure, you should implement a simulated LRT based on a parametric bootstrap. See day 5, on the parametric bootstrap.

### Variance partitioning / ANOVA

Also variance partitioning in mixed models is a bit tricky, as (see type I/II/III ANOVA discussion) fixed and random components of the model are in some way "correlated". Moreover, a key question is (see also interpreatio above): Do you want to count the random effect variance as "explained", or "residual". The most common approach is the hierarchical partitioning proposed by by *Nakagawa & Schielzeth 2013, Nakagawa et al. (2017)*, which is implemented in the `MuMIn`.{R} package. With this, we can run

```{r chunk_chapter4_chunk33, echo=TRUE, eval=TRUE, message=FALSE, warning=FALSE}
library(MuMIn)

r.squaredGLMM(m2) 
```

Interpretation

-   **R2m**: Marginal ${R}^{2}$ value associated with fixed effects.
-   **R2c**: Conditional ${R}^{2}$ value associated with fixed effects plus the random effects.

It is important to note that this is a description of the fitted model, not necessarily valid inference - the reason is that if you add a lot of REs, you will tend to get a lot of variance explained by the RE structure.

As mentioned above, tests for significance of the random effect structure are complicated

## Case studies

::: {.callout-caution icon="false"}
## Case Study 2 - Honeybee Data

We use a dataset on bee colonies infected by the American Foulbrood (AFB) disease.

```{r chunk_chapter4_task_3, message=FALSE, warning=FALSE, eval = TRUE, purl=FALSE}
library(EcoData)
str(bees)
```

Perform the data analysis, according to the hypothesis discussed in the course.
:::

::: {.callout-tip collapse="true" appearance="minimal" icon="false"}
## Solution

```{r chunk_chapter4_task_4, message=FALSE, warning=FALSE}
# adding BeesN as a possible confounder

library(lme4)
fit <- lmer(log(Spobee + 1) ~ Infection + BeesN + (1|Hive), data = bees)
summary(fit)

# residual plot shows that hives are either infected or not, thus 
# doesn't make sense to add a random slope
plot(fit, 
     resid(., scaled=TRUE) ~ fitted(.) | Hive, 
     abline = 0)
```
:::
